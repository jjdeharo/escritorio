import{r as p}from"./vendor-react-CvxLrFbY.js";import{c as Z}from"./vendor-html-parse-stringify-C3VvPRF8.js";import"./vendor-void-elements-SshaXqDN.js";const V=(e,t,n,s)=>{const o=[n,{code:t,...s||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(o,"warn","react-i18next::",!0);O(o[0])&&(o[0]=`react-i18next:: ${o[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...o):console?.warn&&console.warn(...o)},M={},F=(e,t,n,s)=>{O(n)&&M[n]||(O(n)&&(M[n]=new Date),V(e,t,n,s))},W=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},D=(e,t,n)=>{e.loadNamespaces(t,W(e,n))},U=(e,t,n,s)=>{if(O(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return D(e,n,s);n.forEach(o=>{e.options.ns.indexOf(o)<0&&e.options.ns.push(o)}),e.loadLanguages(t,W(e,s))},ee=(e,t,n={})=>!t.languages||!t.languages.length?(F(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(s,o)=>{if(n.bindI18n&&n.bindI18n.indexOf("languageChanging")>-1&&s.services.backendConnector.backend&&s.isLanguageChangingTo&&!o(s.isLanguageChangingTo,e))return!1}}),O=e=>typeof e=="string",k=e=>typeof e=="object"&&e!==null,te=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,ne={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},se=e=>ne[e],re=e=>e.replace(te,se);let z={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:re};const ae=(e={})=>{z={...z,...e}},G=()=>z;let J;const oe=e=>{J=e},B=()=>J,R=(e,t)=>{if(!e)return!1;const n=e.props?.children??e.children;return t?n.length>0:!!n},H=e=>{if(!e)return[];const t=e.props?.children??e.children;return e.props?.i18nIsDynamicList?j(t):t},ie=e=>Array.isArray(e)&&e.every(p.isValidElement),j=e=>Array.isArray(e)?e:[e],ce=(e,t)=>{const n={...t};return n.props=Object.assign(e.props,t.props),n},X=(e,t,n,s)=>{if(!e)return"";let o="";const a=j(e),y=t?.transSupportBasicHtmlNodes?t.transKeepBasicHtmlNodesFor??[]:[];return a.forEach((N,$)=>{if(O(N)){o+=`${N}`;return}if(p.isValidElement(N)){const{props:l,type:g}=N,A=Object.keys(l).length,T=y.indexOf(g)>-1,x=l.children;if(!x&&T&&!A){o+=`<${g}/>`;return}if(!x&&(!T||A)||l.i18nIsDynamicList){o+=`<${$}></${$}>`;return}if(T&&A===1&&O(x)){o+=`<${g}>${x}</${g}>`;return}const f=X(x,t,n,s);o+=`<${$}>${f}</${$}>`;return}if(N===null){V(n,"TRANS_NULL_VALUE","Passed in a null value as child",{i18nKey:s});return}if(k(N)){const{format:l,...g}=N,A=Object.keys(g);if(A.length===1){const T=l?`${A[0]}, ${l}`:A[0];o+=`{{${T}}}`;return}V(n,"TRANS_INVALID_OBJ","Invalid child - Object should only have keys {{ value, format }} (format is optional).",{i18nKey:s,child:N});return}V(n,"TRANS_INVALID_VAR","Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.",{i18nKey:s,child:N})}),o},le=(e,t,n,s,o,a,y)=>{if(n==="")return[];const N=o.transKeepBasicHtmlNodesFor||[],$=n&&new RegExp(N.map(d=>`<${d}`).join("|")).test(n);if(!e&&!t&&!$&&!y)return[n];const l=t??{},g=d=>{j(d).forEach(i=>{O(i)||(R(i)?g(H(i)):k(i)&&!p.isValidElement(i)&&Object.assign(l,i))})};g(e);const A=Z.parse(`<0>${n}</0>`),T={...l,...a},x=(d,m,i)=>{const u=H(d),h=C(u,m.children,i);return ie(u)&&h.length===0||d.props?.i18nIsDynamicList?u:h},f=(d,m,i,u,h)=>{d.dummy?(d.children=m,i.push(p.cloneElement(d,{key:u},h?void 0:m))):i.push(...p.Children.map([d],c=>{const r={...c.props};return delete r.i18nIsDynamicList,p.createElement(c.type,{...r,key:u,ref:c.props.ref??c.ref},h?null:m)}))},C=(d,m,i)=>{const u=j(d);return j(m).reduce((c,r,w)=>{const v=r.children?.[0]?.content&&s.services.interpolator.interpolate(r.children[0].content,T,s.language);if(r.type==="tag"){let I=u[parseInt(r.name,10)];!I&&t&&(I=t[r.name]),i.length===1&&!I&&(I=i[0][r.name]),I||(I={});const E=Object.keys(r.attrs).length!==0?ce({props:r.attrs},I):I,L=p.isValidElement(E),P=L&&R(r,!0)&&!r.voidElement,_=$&&k(E)&&E.dummy&&!L,Q=k(t)&&Object.hasOwnProperty.call(t,r.name);if(O(E)){const S=s.services.interpolator.interpolate(E,T,s.language);c.push(S)}else if(R(E)||P){const S=x(E,r,i);f(E,S,c,w)}else if(_){const S=C(u,r.children,i);f(E,S,c,w)}else if(Number.isNaN(parseFloat(r.name)))if(Q){const S=x(E,r,i);f(E,S,c,w,r.voidElement)}else if(o.transSupportBasicHtmlNodes&&N.indexOf(r.name)>-1)if(r.voidElement)c.push(p.createElement(r.name,{key:`${r.name}-${w}`}));else{const S=C(u,r.children,i);c.push(p.createElement(r.name,{key:`${r.name}-${w}`},S))}else if(r.voidElement)c.push(`<${r.name} />`);else{const S=C(u,r.children,i);c.push(`<${r.name}>${S}</${r.name}>`)}else if(k(E)&&!L){const S=r.children[0]?v:null;S&&c.push(S)}else f(E,v,c,w,r.children.length!==1||!v)}else if(r.type==="text"){const I=o.transWrapTextNodes,E=y?o.unescape(s.services.interpolator.interpolate(r.content,T,s.language)):s.services.interpolator.interpolate(r.content,T,s.language);I?c.push(p.createElement(I,{key:`${r.name}-${w}`},E)):c.push(E)}return c},[])},b=C([{dummy:!0,children:e||[]}],A,j(e||[]));return H(b[0])},q=(e,t,n)=>{const s=e.key||t,o=p.cloneElement(e,{key:s});if(!o.props||!o.props.children||n.indexOf(`${t}/>`)<0&&n.indexOf(`${t} />`)<0)return o;function a(){return p.createElement(p.Fragment,null,o)}return p.createElement(a,{key:s})},ue=(e,t)=>e.map((n,s)=>q(n,s,t)),fe=(e,t)=>{const n={};return Object.keys(e).forEach(s=>{Object.assign(n,{[s]:q(e[s],s,t)})}),n},pe=(e,t,n,s)=>e?Array.isArray(e)?ue(e,t):k(e)?fe(e,t):(F(n,"TRANS_INVALID_COMPONENTS",'<Trans /> "components" prop expects an object or array',{i18nKey:s}),null):null,de=e=>!k(e)||Array.isArray(e)?!1:Object.keys(e).reduce((t,n)=>t&&Number.isNaN(Number.parseFloat(n)),!0);function ge({children:e,count:t,parent:n,i18nKey:s,context:o,tOptions:a={},values:y,defaults:N,components:$,ns:l,i18n:g,t:A,shouldUnescape:T,...x}){const f=g||B();if(!f)return F(f,"NO_I18NEXT_INSTANCE","Trans: You need to pass in an i18next instance using i18nextReactModule",{i18nKey:s}),e;const C=A||f.t.bind(f)||(_=>_),b={...G(),...f.options?.react};let d=l||C.ns||f.options?.defaultNS;d=O(d)?[d]:d||["translation"];const m=X(e,b,f,s),i=N||m||b.transEmptyNodeValue||s,{hashTransKey:u}=b,h=s||(u?u(m||i):m||i);f.options?.interpolation?.defaultVariables&&(y=y&&Object.keys(y).length>0?{...y,...f.options.interpolation.defaultVariables}:{...f.options.interpolation.defaultVariables});const c=y||t!==void 0&&!f.options?.interpolation?.alwaysFormat||!e?a.interpolation:{interpolation:{...a.interpolation,prefix:"#$?",suffix:"?$#"}},r={...a,context:o||a.context,count:t,...y,...c,defaultValue:i,ns:d},w=h?C(h,r):i,v=pe($,w,f,s);let I=v||e,E=null;de(v)&&(E=v,I=e);const L=le(I,E,w,f,b,r,T),P=n??b.defaultTransParent;return P?p.createElement(P,x,L):L}const Te={type:"3rdParty",init(e){ae(e.options.react),oe(e)}},Y=p.createContext();class me{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{this.usedNamespaces[n]||(this.usedNamespaces[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}function xe({children:e,count:t,parent:n,i18nKey:s,context:o,tOptions:a={},values:y,defaults:N,components:$,ns:l,i18n:g,t:A,shouldUnescape:T,...x}){const{i18n:f,defaultNS:C}=p.useContext(Y)||{},b=g||f||B(),d=A||b?.t.bind(b);return ge({children:e,count:t,parent:n,i18nKey:s,context:o,tOptions:a,values:y,defaults:N,components:$,ns:l||d?.ns||C||b?.options?.defaultNS,i18n:b,t:A,shouldUnescape:T,...x})}const ye=(e,t)=>{const n=p.useRef();return p.useEffect(()=>{n.current=e},[e,t]),n.current},K=(e,t,n,s)=>e.getFixedT(t,n,s),Ne=(e,t,n,s)=>p.useCallback(K(e,t,n,s),[e,t,n,s]),Ae=(e,t={})=>{const{i18n:n}=t,{i18n:s,defaultNS:o}=p.useContext(Y)||{},a=n||s||B();if(a&&!a.reportNamespaces&&(a.reportNamespaces=new me),!a){F(a,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const u=(c,r)=>O(r)?r:k(r)&&O(r.defaultValue)?r.defaultValue:Array.isArray(c)?c[c.length-1]:c,h=[u,{},!1];return h.t=u,h.i18n={},h.ready=!1,h}a.options.react?.wait&&F(a,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const y={...G(),...a.options.react,...t},{useSuspense:N,keyPrefix:$}=y;let l=o||a.options?.defaultNS;l=O(l)?[l]:l||["translation"],a.reportNamespaces.addUsedNamespaces?.(l);const g=(a.isInitialized||a.initializedStoreOnce)&&l.every(u=>ee(u,a,y)),A=Ne(a,t.lng||null,y.nsMode==="fallback"?l:l[0],$),T=()=>A,x=()=>K(a,t.lng||null,y.nsMode==="fallback"?l:l[0],$),[f,C]=p.useState(T);let b=l.join();t.lng&&(b=`${t.lng}${b}`);const d=ye(b),m=p.useRef(!0);p.useEffect(()=>{const{bindI18n:u,bindI18nStore:h}=y;m.current=!0,!g&&!N&&(t.lng?U(a,t.lng,l,()=>{m.current&&C(x)}):D(a,l,()=>{m.current&&C(x)})),g&&d&&d!==b&&m.current&&C(x);const c=()=>{m.current&&C(x)};return u&&a?.on(u,c),h&&a?.store.on(h,c),()=>{m.current=!1,a&&u&&u?.split(" ").forEach(r=>a.off(r,c)),h&&a&&h.split(" ").forEach(r=>a.store.off(r,c))}},[a,b]),p.useEffect(()=>{m.current&&g&&C(T)},[a,$,g]);const i=[f,a,g];if(i.t=f,i.i18n=a,i.ready=g,g||!g&&!N)return i;throw new Promise(u=>{t.lng?U(a,t.lng,l,()=>u()):D(a,l,()=>u())})};export{xe as T,Te as i,Ae as u};
